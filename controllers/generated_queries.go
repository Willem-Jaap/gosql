// Generated by gosql: DO NOT EDIT.
package controllers

import (
	"strconv"

	"github.com/gin-gonic/gin"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
)

type AccountListQuery struct {
	Page      int               `json:"page"`
	Limit     int               `json:"limit"`
	Filter    *AccountFilter    `json:"filter"`
	Relations *AccountRelations `json:"relations"`
}

func parseAccountListQuery(context *gin.Context) (*AccountListQuery, error) {
	page, pageExists := context.GetQuery("page")
	limit, limitExists := context.GetQuery("limit")
	filter, filterExists := context.GetQuery("filter")
	relations, relationsExists := context.GetQuery("rels")

	if !pageExists {
		page = "1"
	}

	if !limitExists {
		limit = "10"
	}

	if !filterExists {
		filter = "{}"
	}

	if !relationsExists {
		relations = "{}"
	}

	f, err := parseAccountFilter(filter)
	if err != nil {
		return nil, err
	}

	r, err := parseAccountRelations(filter)
	if err != nil {
		return nil, err
	}

	pageInInt, err := strconv.Atoi(page)
	if err != nil {
		return nil, err
	}

	limitInInt, err := strconv.Atoi(limit)
	if err != nil {
		return nil, err
	}

	return &AccountListQuery{
		Page:      pageInInt,
		Limit:     limitInInt,
		Filter:    f,
		Relations: r,
	}, nil
}

func ParseAccountListQueryToMods(context *gin.Context) ([]qm.QueryMod, error) {
	query, err := parseAccountListQuery(context)
	if err != nil {
		return nil, err
	}

	var queryMods []qm.QueryMod

	queryMods = append(queryMods, qm.Offset(query.Page))
	queryMods = append(queryMods, qm.Limit(query.Limit))

	if query.Filter != nil {
		filterQueryMods, err := parseAccountFilterToMods(query.Filter)
		if err != nil {
			return nil, err
		}
		queryMods = append(queryMods, filterQueryMods...)
	}

	if query.Relations != nil {
		relationQueryMods, err := parseAccountRelationsToMods(query.Relations)
		if err != nil {
			return nil, err
		}
		queryMods = append(queryMods, relationQueryMods...)
	}

	return queryMods, nil
}

type ProxyListQuery struct {
	Page      int             `json:"page"`
	Limit     int             `json:"limit"`
	Filter    *ProxyFilter    `json:"filter"`
	Relations *ProxyRelations `json:"relations"`
}

func parseProxyListQuery(context *gin.Context) (*ProxyListQuery, error) {
	page, pageExists := context.GetQuery("page")
	limit, limitExists := context.GetQuery("limit")
	filter, filterExists := context.GetQuery("filter")
	relations, relationsExists := context.GetQuery("rels")

	if !pageExists {
		page = "1"
	}

	if !limitExists {
		limit = "10"
	}

	if !filterExists {
		filter = "{}"
	}

	if !relationsExists {
		relations = "{}"
	}

	f, err := parseProxyFilter(filter)
	if err != nil {
		return nil, err
	}

	r, err := parseProxyRelations(filter)
	if err != nil {
		return nil, err
	}

	pageInInt, err := strconv.Atoi(page)
	if err != nil {
		return nil, err
	}

	limitInInt, err := strconv.Atoi(limit)
	if err != nil {
		return nil, err
	}

	return &ProxyListQuery{
		Page:      pageInInt,
		Limit:     limitInInt,
		Filter:    f,
		Relations: r,
	}, nil
}

func ParseProxyListQueryToMods(context *gin.Context) ([]qm.QueryMod, error) {
	query, err := parseProxyListQuery(context)
	if err != nil {
		return nil, err
	}

	var queryMods []qm.QueryMod

	queryMods = append(queryMods, qm.Offset(query.Page))
	queryMods = append(queryMods, qm.Limit(query.Limit))

	if query.Filter != nil {
		filterQueryMods, err := parseProxyFilterToMods(query.Filter)
		if err != nil {
			return nil, err
		}
		queryMods = append(queryMods, filterQueryMods...)
	}

	if query.Relations != nil {
		relationQueryMods, err := parseProxyRelationsToMods(query.Relations)
		if err != nil {
			return nil, err
		}
		queryMods = append(queryMods, relationQueryMods...)
	}

	return queryMods, nil
}

type CredentialListQuery struct {
	Page      int                  `json:"page"`
	Limit     int                  `json:"limit"`
	Filter    *CredentialFilter    `json:"filter"`
	Relations *CredentialRelations `json:"relations"`
}

func parseCredentialListQuery(context *gin.Context) (*CredentialListQuery, error) {
	page, pageExists := context.GetQuery("page")
	limit, limitExists := context.GetQuery("limit")
	filter, filterExists := context.GetQuery("filter")
	relations, relationsExists := context.GetQuery("rels")

	if !pageExists {
		page = "1"
	}

	if !limitExists {
		limit = "10"
	}

	if !filterExists {
		filter = "{}"
	}

	if !relationsExists {
		relations = "{}"
	}

	f, err := parseCredentialFilter(filter)
	if err != nil {
		return nil, err
	}

	r, err := parseCredentialRelations(filter)
	if err != nil {
		return nil, err
	}

	pageInInt, err := strconv.Atoi(page)
	if err != nil {
		return nil, err
	}

	limitInInt, err := strconv.Atoi(limit)
	if err != nil {
		return nil, err
	}

	return &CredentialListQuery{
		Page:      pageInInt,
		Limit:     limitInInt,
		Filter:    f,
		Relations: r,
	}, nil
}

func ParseCredentialListQueryToMods(context *gin.Context) ([]qm.QueryMod, error) {
	query, err := parseCredentialListQuery(context)
	if err != nil {
		return nil, err
	}

	var queryMods []qm.QueryMod

	queryMods = append(queryMods, qm.Offset(query.Page))
	queryMods = append(queryMods, qm.Limit(query.Limit))

	if query.Filter != nil {
		filterQueryMods, err := parseCredentialFilterToMods(query.Filter)
		if err != nil {
			return nil, err
		}
		queryMods = append(queryMods, filterQueryMods...)
	}

	if query.Relations != nil {
		relationQueryMods, err := parseCredentialRelationsToMods(query.Relations)
		if err != nil {
			return nil, err
		}
		queryMods = append(queryMods, relationQueryMods...)
	}

	return queryMods, nil
}

type JobListQuery struct {
	Page      int           `json:"page"`
	Limit     int           `json:"limit"`
	Filter    *JobFilter    `json:"filter"`
	Relations *JobRelations `json:"relations"`
}

func parseJobListQuery(context *gin.Context) (*JobListQuery, error) {
	page, pageExists := context.GetQuery("page")
	limit, limitExists := context.GetQuery("limit")
	filter, filterExists := context.GetQuery("filter")
	relations, relationsExists := context.GetQuery("rels")

	if !pageExists {
		page = "1"
	}

	if !limitExists {
		limit = "10"
	}

	if !filterExists {
		filter = "{}"
	}

	if !relationsExists {
		relations = "{}"
	}

	f, err := parseJobFilter(filter)
	if err != nil {
		return nil, err
	}

	r, err := parseJobRelations(filter)
	if err != nil {
		return nil, err
	}

	pageInInt, err := strconv.Atoi(page)
	if err != nil {
		return nil, err
	}

	limitInInt, err := strconv.Atoi(limit)
	if err != nil {
		return nil, err
	}

	return &JobListQuery{
		Page:      pageInInt,
		Limit:     limitInInt,
		Filter:    f,
		Relations: r,
	}, nil
}

func ParseJobListQueryToMods(context *gin.Context) ([]qm.QueryMod, error) {
	query, err := parseJobListQuery(context)
	if err != nil {
		return nil, err
	}

	var queryMods []qm.QueryMod

	queryMods = append(queryMods, qm.Offset(query.Page))
	queryMods = append(queryMods, qm.Limit(query.Limit))

	if query.Filter != nil {
		filterQueryMods, err := parseJobFilterToMods(query.Filter)
		if err != nil {
			return nil, err
		}
		queryMods = append(queryMods, filterQueryMods...)
	}

	if query.Relations != nil {
		relationQueryMods, err := parseJobRelationsToMods(query.Relations)
		if err != nil {
			return nil, err
		}
		queryMods = append(queryMods, relationQueryMods...)
	}

	return queryMods, nil
}

type InstagramAccountListQuery struct {
	Page      int                        `json:"page"`
	Limit     int                        `json:"limit"`
	Filter    *InstagramAccountFilter    `json:"filter"`
	Relations *InstagramAccountRelations `json:"relations"`
}

func parseInstagramAccountListQuery(context *gin.Context) (*InstagramAccountListQuery, error) {
	page, pageExists := context.GetQuery("page")
	limit, limitExists := context.GetQuery("limit")
	filter, filterExists := context.GetQuery("filter")
	relations, relationsExists := context.GetQuery("rels")

	if !pageExists {
		page = "1"
	}

	if !limitExists {
		limit = "10"
	}

	if !filterExists {
		filter = "{}"
	}

	if !relationsExists {
		relations = "{}"
	}

	f, err := parseInstagramAccountFilter(filter)
	if err != nil {
		return nil, err
	}

	r, err := parseInstagramAccountRelations(filter)
	if err != nil {
		return nil, err
	}

	pageInInt, err := strconv.Atoi(page)
	if err != nil {
		return nil, err
	}

	limitInInt, err := strconv.Atoi(limit)
	if err != nil {
		return nil, err
	}

	return &InstagramAccountListQuery{
		Page:      pageInInt,
		Limit:     limitInInt,
		Filter:    f,
		Relations: r,
	}, nil
}

func ParseInstagramAccountListQueryToMods(context *gin.Context) ([]qm.QueryMod, error) {
	query, err := parseInstagramAccountListQuery(context)
	if err != nil {
		return nil, err
	}

	var queryMods []qm.QueryMod

	queryMods = append(queryMods, qm.Offset(query.Page))
	queryMods = append(queryMods, qm.Limit(query.Limit))

	if query.Filter != nil {
		filterQueryMods, err := parseInstagramAccountFilterToMods(query.Filter)
		if err != nil {
			return nil, err
		}
		queryMods = append(queryMods, filterQueryMods...)
	}

	if query.Relations != nil {
		relationQueryMods, err := parseInstagramAccountRelationsToMods(query.Relations)
		if err != nil {
			return nil, err
		}
		queryMods = append(queryMods, relationQueryMods...)
	}

	return queryMods, nil
}

type ScrapedInstagramAccountListQuery struct {
	Page      int                               `json:"page"`
	Limit     int                               `json:"limit"`
	Filter    *ScrapedInstagramAccountFilter    `json:"filter"`
	Relations *ScrapedInstagramAccountRelations `json:"relations"`
}

func parseScrapedInstagramAccountListQuery(context *gin.Context) (*ScrapedInstagramAccountListQuery, error) {
	page, pageExists := context.GetQuery("page")
	limit, limitExists := context.GetQuery("limit")
	filter, filterExists := context.GetQuery("filter")
	relations, relationsExists := context.GetQuery("rels")

	if !pageExists {
		page = "1"
	}

	if !limitExists {
		limit = "10"
	}

	if !filterExists {
		filter = "{}"
	}

	if !relationsExists {
		relations = "{}"
	}

	f, err := parseScrapedInstagramAccountFilter(filter)
	if err != nil {
		return nil, err
	}

	r, err := parseScrapedInstagramAccountRelations(filter)
	if err != nil {
		return nil, err
	}

	pageInInt, err := strconv.Atoi(page)
	if err != nil {
		return nil, err
	}

	limitInInt, err := strconv.Atoi(limit)
	if err != nil {
		return nil, err
	}

	return &ScrapedInstagramAccountListQuery{
		Page:      pageInInt,
		Limit:     limitInInt,
		Filter:    f,
		Relations: r,
	}, nil
}

func ParseScrapedInstagramAccountListQueryToMods(context *gin.Context) ([]qm.QueryMod, error) {
	query, err := parseScrapedInstagramAccountListQuery(context)
	if err != nil {
		return nil, err
	}

	var queryMods []qm.QueryMod

	queryMods = append(queryMods, qm.Offset(query.Page))
	queryMods = append(queryMods, qm.Limit(query.Limit))

	if query.Filter != nil {
		filterQueryMods, err := parseScrapedInstagramAccountFilterToMods(query.Filter)
		if err != nil {
			return nil, err
		}
		queryMods = append(queryMods, filterQueryMods...)
	}

	if query.Relations != nil {
		relationQueryMods, err := parseScrapedInstagramAccountRelationsToMods(query.Relations)
		if err != nil {
			return nil, err
		}
		queryMods = append(queryMods, relationQueryMods...)
	}

	return queryMods, nil
}

type ScrapedInstagramAccountChainedListQuery struct {
	Page      int                                      `json:"page"`
	Limit     int                                      `json:"limit"`
	Filter    *ScrapedInstagramAccountChainedFilter    `json:"filter"`
	Relations *ScrapedInstagramAccountChainedRelations `json:"relations"`
}

func parseScrapedInstagramAccountChainedListQuery(context *gin.Context) (*ScrapedInstagramAccountChainedListQuery, error) {
	page, pageExists := context.GetQuery("page")
	limit, limitExists := context.GetQuery("limit")
	filter, filterExists := context.GetQuery("filter")
	relations, relationsExists := context.GetQuery("rels")

	if !pageExists {
		page = "1"
	}

	if !limitExists {
		limit = "10"
	}

	if !filterExists {
		filter = "{}"
	}

	if !relationsExists {
		relations = "{}"
	}

	f, err := parseScrapedInstagramAccountChainedFilter(filter)
	if err != nil {
		return nil, err
	}

	r, err := parseScrapedInstagramAccountChainedRelations(filter)
	if err != nil {
		return nil, err
	}

	pageInInt, err := strconv.Atoi(page)
	if err != nil {
		return nil, err
	}

	limitInInt, err := strconv.Atoi(limit)
	if err != nil {
		return nil, err
	}

	return &ScrapedInstagramAccountChainedListQuery{
		Page:      pageInInt,
		Limit:     limitInInt,
		Filter:    f,
		Relations: r,
	}, nil
}

func ParseScrapedInstagramAccountChainedListQueryToMods(context *gin.Context) ([]qm.QueryMod, error) {
	query, err := parseScrapedInstagramAccountChainedListQuery(context)
	if err != nil {
		return nil, err
	}

	var queryMods []qm.QueryMod

	queryMods = append(queryMods, qm.Offset(query.Page))
	queryMods = append(queryMods, qm.Limit(query.Limit))

	if query.Filter != nil {
		filterQueryMods, err := parseScrapedInstagramAccountChainedFilterToMods(query.Filter)
		if err != nil {
			return nil, err
		}
		queryMods = append(queryMods, filterQueryMods...)
	}

	if query.Relations != nil {
		relationQueryMods, err := parseScrapedInstagramAccountChainedRelationsToMods(query.Relations)
		if err != nil {
			return nil, err
		}
		queryMods = append(queryMods, relationQueryMods...)
	}

	return queryMods, nil
}
