// Generated by gosql: DO NOT EDIT.
package {{ .PackageName }}

import (
	"encoding/json"

	"github.com/volatiletech/sqlboiler/v4/queries/qm"
)

{{ range $controller := .Controllers }}
	// We don't have a way of knowing if a relation is a one-to-one or a one-to-many, because we don't know where it is used
	type {{ .CamelName }}RelationPagination struct {
		PagePagination  int `json:"_page"`
		LimitPagination int `json:"_limit"`
	}


    type {{ .CamelName}}Relations struct {
        {{ range $relation := .Relations }}
			{{ .Name }} *{{.SingularName}}Relations `boil:"{{ toSnake .Name }}" json:"{{ toSnake .Name }}" toml:"{{ toSnake .Name }}" yaml:"{{ toSnake .Name }}"`
        {{- end }}
		*{{ .CamelName }}RelationPagination
		SelectColumns []string `json:"_select"`
		OrderColumns *{{.CamelName}}OrderColumns `json:"_order"`
		WhereColumns *{{.CamelName }}Filter `json:"_where"`
    }

	func parse{{ .CamelName }}Relations(relations string) (*{{ .CamelName }}Relations, error) {
		var relationsValue {{ .CamelName }}Relations
		if err := json.Unmarshal([]byte(relations), &relationsValue); err != nil {
			return nil, err
		}

		return &relationsValue, nil
	}

	func parse{{ .CamelName}}RelationsToMods(relations *{{ .CamelName}}Relations, loadFrom string, parentLimit int) ([]qm.QueryMod, error) {
		var queryMods []qm.QueryMod

		{{ $relationName := .CamelName }}
		{{ $relationSnakeName := .SnakeName }}
		{{ range $relation := .Relations }}
		if relations.{{ .Name }} != nil {
			if len(loadFrom) > 0 {
				loadFrom += "."
			}

			var relationQueryMods []qm.QueryMod

			if len(relations.{{.Name}}.SelectColumns)>0 {
				selectMods, err := parse{{.SingularName}}SelectsToMods(relations.{{.Name}}.SelectColumns)
				if err != nil {
					return nil, err
				}
				relationQueryMods = append(relationQueryMods, selectMods)
			}

			if relations.{{.Name}}.WhereColumns != nil {
				whereMods, err := parse{{.SingularName}}FilterToMods(relations.{{.Name}}.WhereColumns, "{{toSnake .SingularName}}.")
				if err != nil {
					return nil, err
				}
				relationQueryMods = append(relationQueryMods,  qm.Expr(whereMods...))
			}

			if relations.{{.Name}}.OrderColumns != nil {
				orderMods ,err := parse{{.SingularName}}OrdersToMods(relations.{{.Name}}.OrderColumns)
				if err != nil {
					return nil, err
				}
				relationQueryMods = append(relationQueryMods, orderMods...)
			}

			{{- if .IsArray }}
				limit := 10
				if parentLimit > 10 {
					limit = parentLimit
				}
				page := 0
				if relations.{{ .Name }}.{{ .SingularName }}RelationPagination != nil {
					if relations.{{ .Name }}.LimitPagination > 0 {
						limit = relations.{{ .Name }}.LimitPagination
						if limit > 25 {
							limit = 25
						}
					}
					if relations.{{ .Name }}.PagePagination > 0 {
						page = relations.{{ .Name }}.PagePagination
					}
				}

				relationQueryMods = append(relationQueryMods, qm.Offset(page))
				relationQueryMods = append(relationQueryMods, qm.Limit(limit))
				relationQueryMods = append(relationQueryMods, qm.GroupBy("{{toSnake .SingularName}}.id, {{toSnake .SingularName}}.{{ $relationSnakeName}}_id"))
				
				queryMods = append(queryMods, qm.Load(loadFrom+"{{ .Name }}", relationQueryMods...))
			{{- else }}
				queryMods = append(queryMods, qm.Load(loadFrom+"{{ .Name }}", relationQueryMods...))
			{{- end}}
			
			deeperQueryMods, err := parse{{.SingularName}}RelationsToMods(relations.{{ .Name }}, loadFrom +"{{.Name}}", {{- if .IsArray }} limit {{- else }} parentLimit {{- end}})
			if err != nil {
				return nil, err
			}

			queryMods = append(queryMods, deeperQueryMods...)
		}
		{{- end }}

		return queryMods, nil
	}
{{ end }}
