// Generated by gosql: DO NOT EDIT.
package {{ .PackageName}}

import (
	"database/sql"
	"errors"
	"net/http"
	"os"
	"strings"


	"github.com/gin-gonic/gin"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"golang.org/x/crypto/bcrypt"

{{ range $v := .Imports }}
    "{{ . }}"
{{- end }}
)

type AuthController struct {
	*Client
}

type SignInBody struct {
	Email    string `json:"email" validate:"regexp=^[0-9a-z]+@[0-9a-z]+(\\.[0-9a-z]+)+$"`
	Password string `json:"password" validate:"min=8,max=32"`
}

func (c *AuthController) SignIn(ctx *gin.Context) {
	var body SignInBody
	if err := BindAndValidateJSON(ctx, &body); err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, ResponseWithPayload(nil, "invalid_request", "Invalid request", false, nil))
		return
	}

	var queryMods []qm.QueryMod
	queryMods = append(queryMods, qm.Where("email = ?", body.Email))

	{{- if and .HasOrganization .HasOrganizationUser}}
		queryMods = append(queryMods, qm.Load(dm.{{ .CamelName }}Rels.{{ pluralize .OrganizationUserCamelName}}))
		queryMods = append(queryMods, qm.Load(dm.{{ .CamelName }}Rels.{{ pluralize .OrganizationUserCamelName}} + "." + dm.{{ .OrganizationUserCamelName}}Rels.{{ .OrganizationCamelName}}))
	{{- end}}

	{{ $dbVariable := firstToLower .CamelName}}

	{{ $dbVariable }}, err := dm.{{pluralize .CamelName}}(queryMods...).One(ctx, c.db)
	if err != nil && !errors.Is(err, sql.ErrNoRows) {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, ResponseWithPayload(nil, "invalid_request", "Invalid request", false, nil))
		return
	}
	if {{ $dbVariable }} == nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, ResponseWithPayload(nil, "incorrect_auth", "Email or password is incorrect", false, nil))
		return
	}

	err = bcrypt.CompareHashAndPassword([]byte(account.Password), []byte(body.Password))
	if err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, ResponseWithPayload(nil, "incorrect_auth", "Email or password is incorrect", false, nil))
		return
	}

	{{ $userCamelName := .CamelName}}
	{{ $organizationCamelName := .OrganizationCamelName}}
	{{ $organizationUserCamelName := .OrganizationUserCamelName}}

	jwtPayload := &JWTPayload{
		{{- range $jwt := .JWTFields }}
			{{- if .IsFromUserTable }}
        		{{ .CamelName }}: {{ $dbVariable }}.{{.NormalName}},
			{{- else if .IsFromOrganizationTable }}
				{{ .CamelName }}: {{ $dbVariable }}.R.{{ pluralize $organizationUserCamelName }}[0].R.{{ $organizationCamelName}}.{{.NormalName}},
			{{- else if .IsFromOrganizationUserTable }}
				{{ .CamelName }}: {{ $dbVariable }}.R.{{ pluralize $organizationUserCamelName }}[0].{{.NormalName}},
			{{- end}}
    	{{- end }}
	}
	tokenString, err := GenerateJWT(jwtPayload)
	if err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, ResponseWithPayload(nil, "invalid_input", "Invalid input", false, nil))
		return
	}
	ctx.SetSameSite(http.SameSiteLaxMode)
	ctx.SetCookie("Authorization", tokenString, 3600*24*7, "/", os.Getenv("APP_DOMAIN"), false, true)

	ctx.JSON(http.StatusOK, ResponseWithPayload(am.SqlBoiler{{ .CamelName }}ToApi{{ .CamelName }}({{ $dbVariable}}, nil), nil, nil, true, nil))
}

type SignUpBody struct {
	{{.CamelName}} *AccountCreateBody `json:"account" validate:"nonzero"`
	{{- if and .HasOrganization .HasOrganizationUser}}
		{{ .OrganizationCamelName}} struct {
			*{{ .OrganizationCamelName }}CreateBody `validate:"nonzero"`
			*{{ .OrganizationUserCamelName }}CreateBodyWithoutRelations `validate:"nonzero"`
		} `json:"organization" validate:"nonzero"`
	{{- end }}
}

func (c *AuthController) SignUp(ctx *gin.Context) {
	var body SignUpBody
	if err := BindAndValidateJSON(ctx, &body); err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, ResponseWithPayload(nil, "invalid_request", "Invalid request", false, nil))
		return
	}

	if err := validateObject(body.{{.CamelName}}); err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, ResponseWithPayload(nil, "invalid_request", "Invalid request", false, nil))
		return
	}

	{{ if and .HasOrganization .HasOrganizationUser}}
		if err := validateObject(body.{{ .OrganizationCamelName}}.{{.OrganizationCamelName}}CreateBody); err != nil {
			ctx.AbortWithStatusJSON(http.StatusBadRequest, ResponseWithPayload(nil, "invalid_request", "Invalid request", false, nil))
			return
		}

		if err := validateObject(body.{{ .OrganizationCamelName}}.{{.OrganizationUserCamelName}}CreateBodyWithoutRelations); err != nil {
			ctx.AbortWithStatusJSON(http.StatusBadRequest, ResponseWithPayload(nil, "invalid_request", "Invalid request", false, nil))
			return
		}
	{{- end }}

	var tokenString string
	err := Transactor(c.db, func(tx *sql.Tx) error {
		var queryMods []qm.QueryMod
		{{- $controller := .}}
		{{- $controllerCamelName := .CamelName}}
		{{- range $column := .CreateColumns }}
			{{- if isUnique . }}
				{{- if isNotFirstUnique $controller.CreateColumns $column }}
					queryMods = append(queryMods, qm.Or2(dm.{{ $controllerCamelName }}Where.{{ .CamelName }}.EQ(body.{{$controllerCamelName}}.{{ .CamelName }})))
				{{- else }}
					queryMods = append(queryMods, dm.{{ $controllerCamelName }}Where.{{ .CamelName }}.EQ(body.{{$controllerCamelName}}.{{ .CamelName }}))
				{{- end}}
			{{- end}}
		{{- end}}

		if len(queryMods) > 0 {
			count, err := dm.{{pluralize .CamelName}}(queryMods...).Count(ctx, c.db)
			if err != nil && !errors.Is(err, sql.ErrNoRows) {
				return errors.New("Invalid request")
			}
			if count > 0 {
				return errors.New("{{ .CamelName }} already exists")
			}
		}

		{{- if and .HasOrganization .HasOrganizationUser}}
			var organizationQueryMods []qm.QueryMod
			{{- $organizationCreateColumns := .OrganizationCreateColumns}}
			{{- $controllerCamelName := .OrganizationCamelName}}
			{{- range $column := .OrganizationCreateColumns }}
				{{- if isUnique . }}
					{{- if isNotFirstUnique $organizationCreateColumns $column }}
						organizationQueryMods = append(organizationQueryMods, qm.Or2(dm.{{ $controllerCamelName }}Where.{{ .CamelName }}.EQ(body.{{$controllerCamelName}}.{{ .CamelName }})))
					{{- else }}
						queryMods = append(organizationQueryMods, dm.{{ $controllerCamelName }}Where.{{ .CamelName }}.EQ(body.{{$controllerCamelName}}.{{ .CamelName }}))
					{{- end}}
				{{- end}}
			{{- end}}

			if len(organizationQueryMods) > 0 {
				count, err := dm.{{pluralize .OrganizationCamelName}}(queryMods...).Count(ctx, c.db)
				if err != nil && !errors.Is(err, sql.ErrNoRows) {
					return errors.New("Invalid request")
				}
				if count > 0 {
					return errors.New("{{ .OrganizationCamelName }} already exists")
				}
			}
		{{- end }}

		model{{.CamelName}} := {{  .CamelName}}CreateBodyToSqlBoiler(ctx, body.{{.CamelName}})
		hashedPassword, err := bcrypt.GenerateFromPassword([]byte(body.{{.CamelName}}.Password), 14)
		if err != nil {
			return errors.New("Something went wrong, try again later")
		}

		model{{.CamelName}}.Password = string(hashedPassword)
		err = model{{.CamelName}}.Insert(ctx, c.db, boil.Infer())
		if err != nil {
			return errors.New("Something went wrong, try again later")
		}

		{{ if and .HasOrganization .HasOrganizationUser}}
			model{{.OrganizationCamelName}} := {{  .OrganizationCamelName}}CreateBodyToSqlBoiler(ctx, body.{{.OrganizationCamelName}}.{{.OrganizationCamelName}}CreateBody)
			err = model{{.OrganizationCamelName}}.Insert(ctx, c.db, boil.Infer())
			if err != nil {
				return errors.New("Something went wrong, try again later")
			}
			
			model{{.OrganizationUserCamelName}} := {{  .OrganizationUserCamelName}}CreateBodyToSqlBoiler(ctx, &{{.OrganizationUserCamelName}}CreateBody{
				{{ .OrganizationCamelName}}ID: model{{.OrganizationCamelName}}.ID,
				{{ .CamelName}}ID: model{{.CamelName}}.ID,
				{{- range .OrganizationUserCreateColumns }}
					{{- if or (contains .CamelName $organizationCamelName) (contains .CamelName $userCamelName) }}
					{{- else}}
						{{ .CamelName }}: body.{{ $organizationCamelName}}.{{.CamelName}},
					{{- end }}
				{{- end }}
			})
			err = model{{.OrganizationUserCamelName}}.Insert(ctx, c.db, boil.Infer())
			if err != nil {
				return errors.New("Something went wrong, try again later")
			}

		{{- end}}

		jwtPayload := &JWTPayload{
			{{- range $jwt := .JWTFields }}
				{{- if .IsFromUserTable }}
					{{ .CamelName }}: model{{ $userCamelName }}.{{.NormalName}},
				{{- else if .IsFromOrganizationTable }}
					{{ .CamelName }}: model{{ $organizationCamelName}}.{{.NormalName}},
				{{- else if .IsFromOrganizationUserTable }}
					{{ .CamelName }}: model{{ $organizationUserCamelName}}.{{.NormalName}},
				{{- end}}
			{{- end }}
		}
		tokenString, err = GenerateJWT(jwtPayload)
		if err != nil {
			return errors.New("Invalid request")
		}
		return nil
	})
	if err != nil {
		if strings.Contains(err.Error(), "already exists") {
			ctx.AbortWithStatusJSON(http.StatusBadRequest, ResponseWithPayload(nil, "duplicate", err.Error(), false, nil))
			return
		}

		if strings.Contains(err.Error(), "Invalid request") {
			ctx.AbortWithStatusJSON(http.StatusBadRequest, ResponseWithPayload(nil, "invalid_request", err.Error(), false, nil))
			return
		}

		ctx.AbortWithStatusJSON(http.StatusBadRequest, ResponseWithPayload(nil, "generic", err.Error(), false, nil))
		return
	}

	var queryMods []qm.QueryMod
	queryMods = append(queryMods, qm.Where("email = ?", body.{{.CamelName}}.Email))

	{{- if and .HasOrganization .HasOrganizationUser}}
		queryMods = append(queryMods, qm.Load(dm.{{ .CamelName }}Rels.{{ pluralize .OrganizationUserCamelName}}))
		queryMods = append(queryMods, qm.Load(dm.{{ .CamelName }}Rels.{{ pluralize .OrganizationUserCamelName}} + "." + dm.{{ .OrganizationUserCamelName}}Rels.{{ .OrganizationCamelName}}))
	{{- end}}

	{{ $dbVariable := firstToLower .CamelName}}

	{{ $dbVariable }}, err := dm.{{pluralize .CamelName}}(queryMods...).One(ctx, c.db)
	if err != nil && !errors.Is(err, sql.ErrNoRows) {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, ResponseWithPayload(nil, "invalid_request", "Invalid request", false, nil))
		return
	}
	if {{ $dbVariable }} == nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, ResponseWithPayload(nil, "incorrect_auth", "Email or password is incorrect", false, nil))
		return
	}

	ctx = SetAuthenticationCookie(ctx, tokenString)

	ctx.JSON(http.StatusOK, ResponseWithPayload(am.SqlBoiler{{ .CamelName }}ToApi{{ .CamelName }}({{ $dbVariable }}, nil), nil, nil, true, nil))
}

func (c *AuthController) SignOut(ctx *gin.Context) {
	ctx.SetSameSite(http.SameSiteLaxMode)
	ctx.SetCookie("Authorization", "", -1, "/", os.Getenv("APP_DOMAIN"), false, true)

	ctx.JSON(http.StatusOK, ResponseWithPayload(nil,nil, nil, true, nil))
}

func (c *AuthController) Me(ctx *gin.Context) {
	var queryMods []qm.QueryMod

	{{- range $jwt := .JWTFields }}
		{{- if .IsFromUserTable }}
			queryMods = append(queryMods, qm.Where("{{ toLower .NormalName }} = ?", ctx.Value("{{ .SnakeName }}").({{ .GoType}})))
		{{- else if .IsFromOrganizationTable }}
		{{- else if .IsFromOrganizationUserTable }}
		{{- end}}
	{{- end }}

	{{ if and .HasOrganization .HasOrganizationUser}}
		queryMods = append(queryMods, qm.Load(dm.{{ .CamelName }}Rels.{{ pluralize .OrganizationUserCamelName}}))
		queryMods = append(queryMods, qm.Load(dm.{{ .CamelName }}Rels.{{ pluralize .OrganizationUserCamelName}} + "." + dm.{{ .OrganizationUserCamelName}}Rels.{{ .OrganizationCamelName}}))
	{{- end}}

	payload, err := dm.{{pluralize .CamelName}}( queryMods...).One(ctx, c.db)
	if err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, ResponseWithPayload(nil, "generic", "Something went wrong", false, nil))
		return
	}

	{{- if and .HasOrganization .HasOrganizationUser}}
		returnPayload := gin.H{
			"account": am.SqlBoiler{{ .CamelName }}ToApi{{ .CamelName }}(payload, nil),
			{{- range $jwt := .JWTFields }}
				{{- if .IsFromOrganizationTable }}
					"active_{{.SnakeName}}": ctx.Value("{{ .SnakeName }}"),
				{{- end}}
			{{- end }}
			"token": ctx.Value("auth_token"),
		}
	{{- else}}
		returnPayload := gin.H{
			"account": am.SqlBoiler{{ .CamelName }}ToApi{{ .CamelName }}(payload, nil),
		}
	{{- end}}

	ctx.JSON(http.StatusOK, ResponseWithPayload(returnPayload, nil, nil, true, nil))
}

{{ if and .HasOrganization .HasOrganizationUser}}
	func (c *AuthController) SwitchOrganization(ctx *gin.Context) {
		var body struct {
			{{- range $jwt := .JWTFields }}
				{{- if .IsFromOrganizationTable }}
					{{- if contains .SnakeName "_id" }}
						{{.CamelName}} {{.GoType}} `json:"{{.SnakeName}}" validate:"nonzero"`
					{{- end}}
				{{- end}}
			{{- end }}
		}
		if err := BindAndValidateJSON(ctx, &body); err != nil {
			ctx.AbortWithStatusJSON(http.StatusBadRequest, ResponseWithPayload(nil, "invalid_request", "Invalid request", false, nil))
			return
		}

		var queryMods []qm.QueryMod
		queryMods = append(queryMods, qm.Where("{{ toLower .CamelName }}_id = ?", ctx.Value("{{ toLower .CamelName }}_id").({{- range $jwt := .JWTFields }}{{- if .IsFromOrganizationTable }}{{- if contains .SnakeName "_id" }}{{.GoType}}{{- end}}{{- end}}{{- end}})))
		queryMods = append(queryMods, qm.Where("{{ toLower .OrganizationCamelName }}_id = ?", body.{{- range $jwt := .JWTFields }}{{- if .IsFromOrganizationTable }}{{- if contains .SnakeName "_id" }}{{.CamelName}}{{- end}}{{- end}}{{- end}}))

		queryMods = append(queryMods, qm.Load("{{ .OrganizationCamelName }}"))

		{{ $dbVariable := firstToLower .OrganizationUserCamelName}}
		{{ $dbVariable }}, err := dm.{{pluralize .OrganizationUserCamelName}}(queryMods...).One(ctx, c.db)
		if err != nil {
			ctx.AbortWithStatusJSON(http.StatusBadRequest, ResponseWithPayload(nil, "invalid_request", "Invalid request", false, nil))
			return
		}
		if {{ $dbVariable }} == nil || {{ $dbVariable }}.R == nil || {{$dbVariable}}.R.{{ .OrganizationCamelName}} == nil {
			ctx.AbortWithStatusJSON(http.StatusBadRequest, ResponseWithPayload(nil, "invalid_request", "We can't find that {{ firstToLower .OrganizationCamelName }}", false, nil))
			return
		}

		jwtPayload := &JWTPayload{
			{{- range $jwt := .JWTFields }}
				{{- if .IsFromUserTable }}
					{{ .CamelName }}: ctx.Value("{{ .SnakeName }}").({{ .GoType}}),
				{{- else if .IsFromOrganizationTable }}
					{{ .CamelName }}: {{$dbVariable}}.R.{{ $organizationCamelName}}.{{ .NormalName }},
				{{- else if .IsFromOrganizationUserTable }}
					{{ .CamelName }}: {{ $dbVariable }}.{{.NormalName}},
				{{- end}}
			{{- end }}
		}
		tokenString, err := GenerateJWT(jwtPayload)
		if err != nil {
			ctx.AbortWithStatusJSON(http.StatusBadRequest, ResponseWithPayload(nil, "invalid_request", "Invalid request", false, nil))
			return
		}

		ctx = SetAuthenticationCookie(ctx, tokenString)

		var accountQueryMods []qm.QueryMod
		{{- range $jwt := .JWTFields }}
			{{- if .IsFromUserTable }}
				accountQueryMods = append(accountQueryMods, qm.Where("{{ toLower .NormalName }} = ?", ctx.Value("{{ .SnakeName }}").({{ .GoType}})))
			{{- else if .IsFromOrganizationTable }}
			{{- else if .IsFromOrganizationUserTable }}
			{{- end}}
		{{- end }}

		{{ if and .HasOrganization .HasOrganizationUser}}
			accountQueryMods = append(accountQueryMods, qm.Load(dm.{{ .CamelName }}Rels.{{ pluralize .OrganizationUserCamelName}}))
			accountQueryMods = append(accountQueryMods, qm.Load(dm.{{ .CamelName }}Rels.{{ pluralize .OrganizationUserCamelName}} + "." + dm.{{ .OrganizationUserCamelName}}Rels.{{ .OrganizationCamelName}}))
		{{- end}}

		payload, err := dm.{{pluralize .CamelName}}( accountQueryMods...).One(ctx, c.db)
		if err != nil {
			ctx.AbortWithStatusJSON(http.StatusBadRequest, ResponseWithPayload(nil, "generic", "Something went wrong", false, nil))
			return
		}

		{{- if and .HasOrganization .HasOrganizationUser}}
			returnPayload := gin.H{
				"account": am.SqlBoiler{{ .CamelName }}ToApi{{ .CamelName }}(payload, nil),
				{{- range $jwt := .JWTFields }}
					{{- if .IsFromOrganizationTable }}
						"active_{{.SnakeName}}": {{$dbVariable}}.R.{{ .TableCamelName}}.{{.NormalName}},
					{{- end}}
				{{- end }}
				"token": ctx.Value("auth_token"),
			}
		{{- else}}
			returnPayload := gin.H{
				"account": am.SqlBoiler{{ .CamelName }}ToApi{{ .CamelName }}(payload, nil),
			}
		{{- end}}

		ctx.JSON(http.StatusOK, ResponseWithPayload(returnPayload, nil, nil, true, nil))
	}
{{- end}}