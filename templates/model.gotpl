package {{ .PackageName }}

import (
{{ range $v := .Imports }}
    "{{ . }}"
{{- end }}
)

type {{ .CamelName }} struct {
    {{- range $column := .Columns }}
        {{ .CamelName }} {{ .Type.GoTypeName }} `boil:"{{ .SnakeName }}" json:"{{ if .Expose }}{{ .SnakeName }}{{- else}}-{{- end}}" toml:"{{ .SnakeName }}" yaml:"{{  .SnakeName }}"`
    {{- end }}

{{ range $relation := .Relations }}
    {{ .Name }} {{ .Type }} `boil:"{{ toSnake .Name }}" json:"{{ toSnake .Name }}" toml:"{{ toSnake .Name }}" yaml:"{{ toSnake .Name }}"`
{{- end }}
}

type {{ .CamelName }}Slice []*{{ .CamelName }}

func SqlBoiler{{ pluralize .CamelName }}ToApi{{ pluralize .CamelName }}(a dm.{{ .CamelName }}Slice) {{ .CamelName }}Slice {
    var s {{ .CamelName }}Slice
    for _, d := range a {
        s = append(s, SqlBoiler{{ .CamelName }}ToApi{{ .CamelName }}(d))
    }
    return s
}

func SqlBoiler{{ .CamelName }}ToApi{{ .CamelName }}(a *dm.{{ .CamelName }}) *{{ .CamelName }} {
    p := {{ .CamelName }}{
        {{- range $column := .Columns }}
        {{- if isNullableDBType .}}
            {{ .CamelName }}: null{{ firstToUpper .Type.GoTypeName }}(a.{{ .CamelName }}),
        {{- else }}
            {{ .CamelName }}: a.{{ .CamelName }},
        {{- end}}
        {{- end}}
    }

   if a.R != nil {
        {{- range $relation := .Relations }}
            if a.R.{{ .Name }} != nil {
                p.{{ .Name }} = a.R.{{ .Name }}
            }
        {{- end }}
   }

    return &p
}

