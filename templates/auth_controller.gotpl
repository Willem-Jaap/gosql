// Generated by gosql: DO NOT EDIT.
package {{ .PackageName}}

import (
	"database/sql"
	"errors"
	"net/http"
	"os"

	"github.com/gin-gonic/gin"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"golang.org/x/crypto/bcrypt"

{{ range $v := .Imports }}
    "{{ . }}"
{{- end }}
)

type AuthController struct {
	*Client
}

type AuthBody struct {
	Email    string `json:"email" validate:"regexp=^[0-9a-z]+@[0-9a-z]+(\\.[0-9a-z]+)+$"`
	Password string `json:"password" validate:"min=8,max=32"`
}

func (c *AuthController) SignIn(ctx *gin.Context) {
	var body AuthBody
	if err := bindAndValidateJSON(ctx, &body); err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, responseWithPayload(nil, "invalid_request", "Invalid request", false))
		return
	}

	var queryMods []qm.QueryMod
	queryMods = append(queryMods, qm.Where("email = ?", body.Email))

	{{ $dbVariable := firstToLower .CamelName}}

	{{ $dbVariable }}, err := dm.{{pluralize .CamelName}}(queryMods...).One(ctx, c.db)
	if err != nil && !errors.Is(err, sql.ErrNoRows) {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, responseWithPayload(nil, "invalid_request", "Invalid request", false))
		return
	}
	if {{ $dbVariable }} == nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, responseWithPayload(nil, "incorrect_auth", "Email or password is incorrect", false))
		return
	}

	err = bcrypt.CompareHashAndPassword([]byte(account.Password), []byte(body.Password))
	if err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, responseWithPayload(nil, "incorrect_auth", "Email or password is incorrect", false))
		return
	}

	jwtPayload := &JWTPayload{
		{{- range $jwt := .JWTFields }}
        	{{ .CamelName }}: {{ $dbVariable }}.{{.NormalName}},
    	{{- end }}
	}
	tokenString, err := GenerateJWT(jwtPayload)
	if err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, responseWithPayload(nil, "invalid_input", "Invalid input", false))
		return
	}
	ctx.SetSameSite(http.SameSiteLaxMode)
	ctx.SetCookie("Authorization", tokenString, 3600*24*7, "/", os.Getenv("APP_DOMAIN"), false, true)

	ctx.JSON(http.StatusOK, responseWithPayload(am.SqlBoiler{{ .CamelName }}ToApi{{ .CamelName }}({{ $dbVariable}}), nil, nil, true))
}

func (c *AuthController) SignUp(ctx *gin.Context) {
	body, err := parse{{ .CamelName }}CreateBody(ctx)
	if err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, responseWithPayload(nil, "invalid_request", "Invalid request", false))
		return
	}
	var queryMods []qm.QueryMod
	{{- $controller := .}}
	{{- $controllerCamelName := .CamelName}}
	{{- range $column := .CreateColumns }}
		{{- if isUnique . }}
			{{- if isNotFirstUnique $controller.CreateColumns $column }}
				queryMods = append(queryMods, qm.Or2(dm.{{ $controllerCamelName }}Where.{{ .CamelName }}.EQ(body.{{ .CamelName }})))
			{{- else }}
				queryMods = append(queryMods, dm.{{ $controllerCamelName }}Where.{{ .CamelName }}.EQ(body.{{ .CamelName }}))
			{{- end}}
		{{- end}}
	{{- end}}

	if len(queryMods) > 0 {
		count, err := dm.{{pluralize .CamelName}}(queryMods...).Count(ctx, c.db)
		if err != nil && !errors.Is(err, sql.ErrNoRows) {
			ctx.AbortWithStatusJSON(http.StatusBadRequest, responseWithPayload(nil, "invalid_request", "Invalid request", false))
			return
		}
		if count > 0 {
			ctx.AbortWithStatusJSON(http.StatusBadRequest, responseWithPayload(nil, "duplicate", "Duplicate entry", false))
			return
		}
	}

	model := {{ firstToLower .CamelName}}CreateBodyToSqlBoiler(ctx, body)
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(body.Password), 14)
	if err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, responseWithPayload(nil,"generic", "Something went wrong, try again later", false))
		return
	}

	model.Password = string(hashedPassword)
	err = model.Insert(ctx, c.db, boil.Infer())
	if err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, responseWithPayload(nil, "generic", "Something went wrong", false))
		return
	}

	jwtPayload := &JWTPayload{
		{{- range $jwt := .JWTFields }}
        	{{ .CamelName }}: model.{{ .NormalName }},
    	{{- end }}
	}
	tokenString, err := GenerateJWT(jwtPayload)
	if err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, responseWithPayload(nil, "invalid_input", "Invalid input", false))
		return
	}
	ctx.SetSameSite(http.SameSiteLaxMode)
	ctx.SetCookie("Authorization", tokenString, 3600*24*7, "/", os.Getenv("APP_DOMAIN"), false, true)

	ctx.JSON(http.StatusOK, responseWithPayload(am.SqlBoiler{{ .CamelName }}ToApi{{ .CamelName }}(model), nil, nil, true))
}

func (c *AuthController) SignOut(ctx *gin.Context) {
	ctx.SetSameSite(http.SameSiteLaxMode)
	ctx.SetCookie("Authorization", "", -1, "/", os.Getenv("APP_DOMAIN"), false, true)

	ctx.JSON(http.StatusOK, responseWithPayload(nil,nil, nil, true))
}

func (c *AuthController) Me(ctx *gin.Context) {
	var queryMods []qm.QueryMod

	{{- range $jwt := .JWTFields }}
		queryMods = append(queryMods, qm.Where("{{ toLower .NormalName }} = ?", ctx.Value("{{ .SnakeName }}").({{ .GoType}})))
	{{- end }}

	payload, err := dm.{{pluralize .CamelName}}( queryMods...).One(ctx, c.db)
	if err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, responseWithPayload(nil, "generic", "Something went wrong", false))
		return
	}

	ctx.JSON(http.StatusOK, responseWithPayload(am.SqlBoiler{{ .CamelName }}ToApi{{ .CamelName }}(payload), nil, nil, true))
}