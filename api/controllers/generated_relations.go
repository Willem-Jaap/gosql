// Generated by gosql: DO NOT EDIT.
package controllers

import (
	"encoding/json"

	"github.com/gin-gonic/gin"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
)

type AccountRelations struct {
	InstagramAccounts               *SelectAccountColumns `boil:"instagramAccounts" json:"instagramAccounts" toml:"instagramAccounts" yaml:"instagramAccounts"`
	Proxies                         *SelectAccountColumns `boil:"proxies" json:"proxies" toml:"proxies" yaml:"proxies"`
	ScrapedInstagramAccounts        *SelectAccountColumns `boil:"scrapedInstagramAccounts" json:"scrapedInstagramAccounts" toml:"scrapedInstagramAccounts" yaml:"scrapedInstagramAccounts"`
	ScrapedInstagramAccountChaineds *SelectAccountColumns `boil:"scrapedInstagramAccountChaineds" json:"scrapedInstagramAccountChaineds" toml:"scrapedInstagramAccountChaineds" yaml:"scrapedInstagramAccountChaineds"`
}

func parseAccountRelations(relations string) (*AccountRelations, error) {
	var relationsValue AccountRelations
	if err := json.Unmarshal([]byte(relations), &relationsValue); err != nil {
		return nil, err
	}

	return &relationsValue, nil
}

func parseAccountRelationsToMods(relations *AccountRelations) ([]qm.QueryMod, error) {
	var queryMods []qm.QueryMod
	var selectColumns []string

	if relations.InstagramAccounts != nil {

		if relations.InstagramAccounts.Id != nil && *relations.InstagramAccounts.Id {
			selectColumns = append(selectColumns, "id")
		}
		if relations.InstagramAccounts.Name != nil && *relations.InstagramAccounts.Name {
			selectColumns = append(selectColumns, "name")
		}
		if relations.InstagramAccounts.ProfilePictureUrl != nil && *relations.InstagramAccounts.ProfilePictureUrl {
			selectColumns = append(selectColumns, "profile_picture_url")
		}
		if relations.InstagramAccounts.Email != nil && *relations.InstagramAccounts.Email {
			selectColumns = append(selectColumns, "email")
		}
		if relations.InstagramAccounts.Password != nil && *relations.InstagramAccounts.Password {
			selectColumns = append(selectColumns, "password")
		}
		if relations.InstagramAccounts.CreatedAt != nil && *relations.InstagramAccounts.CreatedAt {
			selectColumns = append(selectColumns, "created_at")
		}
		if relations.InstagramAccounts.UpdatedAt != nil && *relations.InstagramAccounts.UpdatedAt {
			selectColumns = append(selectColumns, "updated_at")
		}
	}
	if relations.Proxies != nil {

		if relations.Proxies.Id != nil && *relations.Proxies.Id {
			selectColumns = append(selectColumns, "id")
		}
		if relations.Proxies.Name != nil && *relations.Proxies.Name {
			selectColumns = append(selectColumns, "name")
		}
		if relations.Proxies.ProfilePictureUrl != nil && *relations.Proxies.ProfilePictureUrl {
			selectColumns = append(selectColumns, "profile_picture_url")
		}
		if relations.Proxies.Email != nil && *relations.Proxies.Email {
			selectColumns = append(selectColumns, "email")
		}
		if relations.Proxies.Password != nil && *relations.Proxies.Password {
			selectColumns = append(selectColumns, "password")
		}
		if relations.Proxies.CreatedAt != nil && *relations.Proxies.CreatedAt {
			selectColumns = append(selectColumns, "created_at")
		}
		if relations.Proxies.UpdatedAt != nil && *relations.Proxies.UpdatedAt {
			selectColumns = append(selectColumns, "updated_at")
		}
	}
	if relations.ScrapedInstagramAccounts != nil {

		if relations.ScrapedInstagramAccounts.Id != nil && *relations.ScrapedInstagramAccounts.Id {
			selectColumns = append(selectColumns, "id")
		}
		if relations.ScrapedInstagramAccounts.Name != nil && *relations.ScrapedInstagramAccounts.Name {
			selectColumns = append(selectColumns, "name")
		}
		if relations.ScrapedInstagramAccounts.ProfilePictureUrl != nil && *relations.ScrapedInstagramAccounts.ProfilePictureUrl {
			selectColumns = append(selectColumns, "profile_picture_url")
		}
		if relations.ScrapedInstagramAccounts.Email != nil && *relations.ScrapedInstagramAccounts.Email {
			selectColumns = append(selectColumns, "email")
		}
		if relations.ScrapedInstagramAccounts.Password != nil && *relations.ScrapedInstagramAccounts.Password {
			selectColumns = append(selectColumns, "password")
		}
		if relations.ScrapedInstagramAccounts.CreatedAt != nil && *relations.ScrapedInstagramAccounts.CreatedAt {
			selectColumns = append(selectColumns, "created_at")
		}
		if relations.ScrapedInstagramAccounts.UpdatedAt != nil && *relations.ScrapedInstagramAccounts.UpdatedAt {
			selectColumns = append(selectColumns, "updated_at")
		}
	}
	if relations.ScrapedInstagramAccountChaineds != nil {

		if relations.ScrapedInstagramAccountChaineds.Id != nil && *relations.ScrapedInstagramAccountChaineds.Id {
			selectColumns = append(selectColumns, "id")
		}
		if relations.ScrapedInstagramAccountChaineds.Name != nil && *relations.ScrapedInstagramAccountChaineds.Name {
			selectColumns = append(selectColumns, "name")
		}
		if relations.ScrapedInstagramAccountChaineds.ProfilePictureUrl != nil && *relations.ScrapedInstagramAccountChaineds.ProfilePictureUrl {
			selectColumns = append(selectColumns, "profile_picture_url")
		}
		if relations.ScrapedInstagramAccountChaineds.Email != nil && *relations.ScrapedInstagramAccountChaineds.Email {
			selectColumns = append(selectColumns, "email")
		}
		if relations.ScrapedInstagramAccountChaineds.Password != nil && *relations.ScrapedInstagramAccountChaineds.Password {
			selectColumns = append(selectColumns, "password")
		}
		if relations.ScrapedInstagramAccountChaineds.CreatedAt != nil && *relations.ScrapedInstagramAccountChaineds.CreatedAt {
			selectColumns = append(selectColumns, "created_at")
		}
		if relations.ScrapedInstagramAccountChaineds.UpdatedAt != nil && *relations.ScrapedInstagramAccountChaineds.UpdatedAt {
			selectColumns = append(selectColumns, "updated_at")
		}
	}

	if len(selectColumns) > 0 {
		queryMods = append(queryMods, qm.Select(selectColumns...))
	}

	return queryMods, nil
}

type ProxyRelations struct {
	Account           *SelectProxyColumns `boil:"account" json:"account" toml:"account" yaml:"account"`
	InstagramAccounts *SelectProxyColumns `boil:"instagramAccounts" json:"instagramAccounts" toml:"instagramAccounts" yaml:"instagramAccounts"`
}

func parseProxyRelations(relations string) (*ProxyRelations, error) {
	var relationsValue ProxyRelations
	if err := json.Unmarshal([]byte(relations), &relationsValue); err != nil {
		return nil, err
	}

	return &relationsValue, nil
}

func parseProxyRelationsToMods(relations *ProxyRelations) ([]qm.QueryMod, error) {
	var queryMods []qm.QueryMod
	var selectColumns []string

	if relations.Account != nil {

		if relations.Account.Id != nil && *relations.Account.Id {
			selectColumns = append(selectColumns, "id")
		}
		if relations.Account.Host != nil && *relations.Account.Host {
			selectColumns = append(selectColumns, "host")
		}
		if relations.Account.Scheme != nil && *relations.Account.Scheme {
			selectColumns = append(selectColumns, "scheme")
		}
		if relations.Account.Port != nil && *relations.Account.Port {
			selectColumns = append(selectColumns, "port")
		}
		if relations.Account.Username != nil && *relations.Account.Username {
			selectColumns = append(selectColumns, "username")
		}
		if relations.Account.Password != nil && *relations.Account.Password {
			selectColumns = append(selectColumns, "password")
		}
		if relations.Account.IsCustomProvider != nil && *relations.Account.IsCustomProvider {
			selectColumns = append(selectColumns, "is_custom_provider")
		}
		if relations.Account.Account != nil && *relations.Account.Account {
			selectColumns = append(selectColumns, "account")
		}
		if relations.Account.CreatedAt != nil && *relations.Account.CreatedAt {
			selectColumns = append(selectColumns, "created_at")
		}
		if relations.Account.UpdatedAt != nil && *relations.Account.UpdatedAt {
			selectColumns = append(selectColumns, "updated_at")
		}
	}
	if relations.InstagramAccounts != nil {

		if relations.InstagramAccounts.Id != nil && *relations.InstagramAccounts.Id {
			selectColumns = append(selectColumns, "id")
		}
		if relations.InstagramAccounts.Host != nil && *relations.InstagramAccounts.Host {
			selectColumns = append(selectColumns, "host")
		}
		if relations.InstagramAccounts.Scheme != nil && *relations.InstagramAccounts.Scheme {
			selectColumns = append(selectColumns, "scheme")
		}
		if relations.InstagramAccounts.Port != nil && *relations.InstagramAccounts.Port {
			selectColumns = append(selectColumns, "port")
		}
		if relations.InstagramAccounts.Username != nil && *relations.InstagramAccounts.Username {
			selectColumns = append(selectColumns, "username")
		}
		if relations.InstagramAccounts.Password != nil && *relations.InstagramAccounts.Password {
			selectColumns = append(selectColumns, "password")
		}
		if relations.InstagramAccounts.IsCustomProvider != nil && *relations.InstagramAccounts.IsCustomProvider {
			selectColumns = append(selectColumns, "is_custom_provider")
		}
		if relations.InstagramAccounts.Account != nil && *relations.InstagramAccounts.Account {
			selectColumns = append(selectColumns, "account")
		}
		if relations.InstagramAccounts.CreatedAt != nil && *relations.InstagramAccounts.CreatedAt {
			selectColumns = append(selectColumns, "created_at")
		}
		if relations.InstagramAccounts.UpdatedAt != nil && *relations.InstagramAccounts.UpdatedAt {
			selectColumns = append(selectColumns, "updated_at")
		}
	}

	if len(selectColumns) > 0 {
		queryMods = append(queryMods, qm.Select(selectColumns...))
	}

	return queryMods, nil
}

type CredentialRelations struct {
	InstagramAccounts *SelectCredentialColumns `boil:"instagramAccounts" json:"instagramAccounts" toml:"instagramAccounts" yaml:"instagramAccounts"`
}

func parseCredentialRelations(relations string) (*CredentialRelations, error) {
	var relationsValue CredentialRelations
	if err := json.Unmarshal([]byte(relations), &relationsValue); err != nil {
		return nil, err
	}

	return &relationsValue, nil
}

func parseCredentialRelationsToMods(relations *CredentialRelations) ([]qm.QueryMod, error) {
	var queryMods []qm.QueryMod
	var selectColumns []string

	if relations.InstagramAccounts != nil {

		if relations.InstagramAccounts.Id != nil && *relations.InstagramAccounts.Id {
			selectColumns = append(selectColumns, "id")
		}
		if relations.InstagramAccounts.CsfrToken != nil && *relations.InstagramAccounts.CsfrToken {
			selectColumns = append(selectColumns, "csfr_token")
		}
		if relations.InstagramAccounts.UserAgent != nil && *relations.InstagramAccounts.UserAgent {
			selectColumns = append(selectColumns, "user_agent")
		}
		if relations.InstagramAccounts.AppId != nil && *relations.InstagramAccounts.AppId {
			selectColumns = append(selectColumns, "app_id")
		}
		if relations.InstagramAccounts.Cookie != nil && *relations.InstagramAccounts.Cookie {
			selectColumns = append(selectColumns, "cookie")
		}
		if relations.InstagramAccounts.InstagramId != nil && *relations.InstagramAccounts.InstagramId {
			selectColumns = append(selectColumns, "instagram_id")
		}
		if relations.InstagramAccounts.CreatedAt != nil && *relations.InstagramAccounts.CreatedAt {
			selectColumns = append(selectColumns, "created_at")
		}
		if relations.InstagramAccounts.UpdatedAt != nil && *relations.InstagramAccounts.UpdatedAt {
			selectColumns = append(selectColumns, "updated_at")
		}
	}

	if len(selectColumns) > 0 {
		queryMods = append(queryMods, qm.Select(selectColumns...))
	}

	return queryMods, nil
}

type JobRelations struct {
	InstagramAccounts *SelectJobColumns `boil:"instagramAccounts" json:"instagramAccounts" toml:"instagramAccounts" yaml:"instagramAccounts"`
}

func parseJobRelations(relations string) (*JobRelations, error) {
	var relationsValue JobRelations
	if err := json.Unmarshal([]byte(relations), &relationsValue); err != nil {
		return nil, err
	}

	return &relationsValue, nil
}

func parseJobRelationsToMods(relations *JobRelations) ([]qm.QueryMod, error) {
	var queryMods []qm.QueryMod
	var selectColumns []string

	if relations.InstagramAccounts != nil {

		if relations.InstagramAccounts.Id != nil && *relations.InstagramAccounts.Id {
			selectColumns = append(selectColumns, "id")
		}
		if relations.InstagramAccounts.Type != nil && *relations.InstagramAccounts.Type {
			selectColumns = append(selectColumns, "type")
		}
		if relations.InstagramAccounts.CreatedAt != nil && *relations.InstagramAccounts.CreatedAt {
			selectColumns = append(selectColumns, "created_at")
		}
		if relations.InstagramAccounts.UpdatedAt != nil && *relations.InstagramAccounts.UpdatedAt {
			selectColumns = append(selectColumns, "updated_at")
		}
	}

	if len(selectColumns) > 0 {
		queryMods = append(queryMods, qm.Select(selectColumns...))
	}

	return queryMods, nil
}

type InstagramAccountRelations struct {
	Account    *SelectInstagramAccountColumns `boil:"account" json:"account" toml:"account" yaml:"account"`
	Credential *SelectInstagramAccountColumns `boil:"credential" json:"credential" toml:"credential" yaml:"credential"`
	Job        *SelectInstagramAccountColumns `boil:"job" json:"job" toml:"job" yaml:"job"`
	Proxy      *SelectInstagramAccountColumns `boil:"proxy" json:"proxy" toml:"proxy" yaml:"proxy"`
}

func parseInstagramAccountRelations(relations string) (*InstagramAccountRelations, error) {
	var relationsValue InstagramAccountRelations
	if err := json.Unmarshal([]byte(relations), &relationsValue); err != nil {
		return nil, err
	}

	return &relationsValue, nil
}

func parseInstagramAccountRelationsToMods(relations *InstagramAccountRelations) ([]qm.QueryMod, error) {
	var queryMods []qm.QueryMod
	var selectColumns []string

	if relations.Account != nil {

		if relations.Account.Id != nil && *relations.Account.Id {
			selectColumns = append(selectColumns, "id")
		}
		if relations.Account.Username != nil && *relations.Account.Username {
			selectColumns = append(selectColumns, "username")
		}
		if relations.Account.Password != nil && *relations.Account.Password {
			selectColumns = append(selectColumns, "password")
		}
		if relations.Account.Country != nil && *relations.Account.Country {
			selectColumns = append(selectColumns, "country")
		}
		if relations.Account.Active != nil && *relations.Account.Active {
			selectColumns = append(selectColumns, "active")
		}
		if relations.Account.TotalActionsDone != nil && *relations.Account.TotalActionsDone {
			selectColumns = append(selectColumns, "total_actions_done")
		}
		if relations.Account.NeedsToBeChecked != nil && *relations.Account.NeedsToBeChecked {
			selectColumns = append(selectColumns, "needs_to_be_checked")
		}
		if relations.Account.LoginFailed != nil && *relations.Account.LoginFailed {
			selectColumns = append(selectColumns, "login_failed")
		}
		if relations.Account.IsSetup != nil && *relations.Account.IsSetup {
			selectColumns = append(selectColumns, "is_setup")
		}
		if relations.Account.SetupTargetAccountUsername != nil && *relations.Account.SetupTargetAccountUsername {
			selectColumns = append(selectColumns, "setup_target_account_username")
		}
		if relations.Account.Proxy != nil && *relations.Account.Proxy {
			selectColumns = append(selectColumns, "proxy")
		}
		if relations.Account.Credential != nil && *relations.Account.Credential {
			selectColumns = append(selectColumns, "credential")
		}
		if relations.Account.Account != nil && *relations.Account.Account {
			selectColumns = append(selectColumns, "account")
		}
		if relations.Account.Job != nil && *relations.Account.Job {
			selectColumns = append(selectColumns, "job")
		}
		if relations.Account.CreatedAt != nil && *relations.Account.CreatedAt {
			selectColumns = append(selectColumns, "created_at")
		}
		if relations.Account.UpdatedAt != nil && *relations.Account.UpdatedAt {
			selectColumns = append(selectColumns, "updated_at")
		}
	}
	if relations.Credential != nil {

		if relations.Credential.Id != nil && *relations.Credential.Id {
			selectColumns = append(selectColumns, "id")
		}
		if relations.Credential.Username != nil && *relations.Credential.Username {
			selectColumns = append(selectColumns, "username")
		}
		if relations.Credential.Password != nil && *relations.Credential.Password {
			selectColumns = append(selectColumns, "password")
		}
		if relations.Credential.Country != nil && *relations.Credential.Country {
			selectColumns = append(selectColumns, "country")
		}
		if relations.Credential.Active != nil && *relations.Credential.Active {
			selectColumns = append(selectColumns, "active")
		}
		if relations.Credential.TotalActionsDone != nil && *relations.Credential.TotalActionsDone {
			selectColumns = append(selectColumns, "total_actions_done")
		}
		if relations.Credential.NeedsToBeChecked != nil && *relations.Credential.NeedsToBeChecked {
			selectColumns = append(selectColumns, "needs_to_be_checked")
		}
		if relations.Credential.LoginFailed != nil && *relations.Credential.LoginFailed {
			selectColumns = append(selectColumns, "login_failed")
		}
		if relations.Credential.IsSetup != nil && *relations.Credential.IsSetup {
			selectColumns = append(selectColumns, "is_setup")
		}
		if relations.Credential.SetupTargetAccountUsername != nil && *relations.Credential.SetupTargetAccountUsername {
			selectColumns = append(selectColumns, "setup_target_account_username")
		}
		if relations.Credential.Proxy != nil && *relations.Credential.Proxy {
			selectColumns = append(selectColumns, "proxy")
		}
		if relations.Credential.Credential != nil && *relations.Credential.Credential {
			selectColumns = append(selectColumns, "credential")
		}
		if relations.Credential.Account != nil && *relations.Credential.Account {
			selectColumns = append(selectColumns, "account")
		}
		if relations.Credential.Job != nil && *relations.Credential.Job {
			selectColumns = append(selectColumns, "job")
		}
		if relations.Credential.CreatedAt != nil && *relations.Credential.CreatedAt {
			selectColumns = append(selectColumns, "created_at")
		}
		if relations.Credential.UpdatedAt != nil && *relations.Credential.UpdatedAt {
			selectColumns = append(selectColumns, "updated_at")
		}
	}
	if relations.Job != nil {

		if relations.Job.Id != nil && *relations.Job.Id {
			selectColumns = append(selectColumns, "id")
		}
		if relations.Job.Username != nil && *relations.Job.Username {
			selectColumns = append(selectColumns, "username")
		}
		if relations.Job.Password != nil && *relations.Job.Password {
			selectColumns = append(selectColumns, "password")
		}
		if relations.Job.Country != nil && *relations.Job.Country {
			selectColumns = append(selectColumns, "country")
		}
		if relations.Job.Active != nil && *relations.Job.Active {
			selectColumns = append(selectColumns, "active")
		}
		if relations.Job.TotalActionsDone != nil && *relations.Job.TotalActionsDone {
			selectColumns = append(selectColumns, "total_actions_done")
		}
		if relations.Job.NeedsToBeChecked != nil && *relations.Job.NeedsToBeChecked {
			selectColumns = append(selectColumns, "needs_to_be_checked")
		}
		if relations.Job.LoginFailed != nil && *relations.Job.LoginFailed {
			selectColumns = append(selectColumns, "login_failed")
		}
		if relations.Job.IsSetup != nil && *relations.Job.IsSetup {
			selectColumns = append(selectColumns, "is_setup")
		}
		if relations.Job.SetupTargetAccountUsername != nil && *relations.Job.SetupTargetAccountUsername {
			selectColumns = append(selectColumns, "setup_target_account_username")
		}
		if relations.Job.Proxy != nil && *relations.Job.Proxy {
			selectColumns = append(selectColumns, "proxy")
		}
		if relations.Job.Credential != nil && *relations.Job.Credential {
			selectColumns = append(selectColumns, "credential")
		}
		if relations.Job.Account != nil && *relations.Job.Account {
			selectColumns = append(selectColumns, "account")
		}
		if relations.Job.Job != nil && *relations.Job.Job {
			selectColumns = append(selectColumns, "job")
		}
		if relations.Job.CreatedAt != nil && *relations.Job.CreatedAt {
			selectColumns = append(selectColumns, "created_at")
		}
		if relations.Job.UpdatedAt != nil && *relations.Job.UpdatedAt {
			selectColumns = append(selectColumns, "updated_at")
		}
	}
	if relations.Proxy != nil {

		if relations.Proxy.Id != nil && *relations.Proxy.Id {
			selectColumns = append(selectColumns, "id")
		}
		if relations.Proxy.Username != nil && *relations.Proxy.Username {
			selectColumns = append(selectColumns, "username")
		}
		if relations.Proxy.Password != nil && *relations.Proxy.Password {
			selectColumns = append(selectColumns, "password")
		}
		if relations.Proxy.Country != nil && *relations.Proxy.Country {
			selectColumns = append(selectColumns, "country")
		}
		if relations.Proxy.Active != nil && *relations.Proxy.Active {
			selectColumns = append(selectColumns, "active")
		}
		if relations.Proxy.TotalActionsDone != nil && *relations.Proxy.TotalActionsDone {
			selectColumns = append(selectColumns, "total_actions_done")
		}
		if relations.Proxy.NeedsToBeChecked != nil && *relations.Proxy.NeedsToBeChecked {
			selectColumns = append(selectColumns, "needs_to_be_checked")
		}
		if relations.Proxy.LoginFailed != nil && *relations.Proxy.LoginFailed {
			selectColumns = append(selectColumns, "login_failed")
		}
		if relations.Proxy.IsSetup != nil && *relations.Proxy.IsSetup {
			selectColumns = append(selectColumns, "is_setup")
		}
		if relations.Proxy.SetupTargetAccountUsername != nil && *relations.Proxy.SetupTargetAccountUsername {
			selectColumns = append(selectColumns, "setup_target_account_username")
		}
		if relations.Proxy.Proxy != nil && *relations.Proxy.Proxy {
			selectColumns = append(selectColumns, "proxy")
		}
		if relations.Proxy.Credential != nil && *relations.Proxy.Credential {
			selectColumns = append(selectColumns, "credential")
		}
		if relations.Proxy.Account != nil && *relations.Proxy.Account {
			selectColumns = append(selectColumns, "account")
		}
		if relations.Proxy.Job != nil && *relations.Proxy.Job {
			selectColumns = append(selectColumns, "job")
		}
		if relations.Proxy.CreatedAt != nil && *relations.Proxy.CreatedAt {
			selectColumns = append(selectColumns, "created_at")
		}
		if relations.Proxy.UpdatedAt != nil && *relations.Proxy.UpdatedAt {
			selectColumns = append(selectColumns, "updated_at")
		}
	}

	if len(selectColumns) > 0 {
		queryMods = append(queryMods, qm.Select(selectColumns...))
	}

	return queryMods, nil
}

type ScrapedInstagramAccountRelations struct {
	Account                         *SelectScrapedInstagramAccountColumns `boil:"account" json:"account" toml:"account" yaml:"account"`
	ScrapedInstagramAccountChaineds *SelectScrapedInstagramAccountColumns `boil:"scrapedInstagramAccountChaineds" json:"scrapedInstagramAccountChaineds" toml:"scrapedInstagramAccountChaineds" yaml:"scrapedInstagramAccountChaineds"`
}

func parseScrapedInstagramAccountRelations(relations string) (*ScrapedInstagramAccountRelations, error) {
	var relationsValue ScrapedInstagramAccountRelations
	if err := json.Unmarshal([]byte(relations), &relationsValue); err != nil {
		return nil, err
	}

	return &relationsValue, nil
}

func parseScrapedInstagramAccountRelationsToMods(relations *ScrapedInstagramAccountRelations) ([]qm.QueryMod, error) {
	var queryMods []qm.QueryMod
	var selectColumns []string

	if relations.Account != nil {

		if relations.Account.Id != nil && *relations.Account.Id {
			selectColumns = append(selectColumns, "id")
		}
		if relations.Account.InstagramId != nil && *relations.Account.InstagramId {
			selectColumns = append(selectColumns, "instagram_id")
		}
		if relations.Account.Username != nil && *relations.Account.Username {
			selectColumns = append(selectColumns, "username")
		}
		if relations.Account.FullName != nil && *relations.Account.FullName {
			selectColumns = append(selectColumns, "full_name")
		}
		if relations.Account.Biography != nil && *relations.Account.Biography {
			selectColumns = append(selectColumns, "biography")
		}
		if relations.Account.FacebookId != nil && *relations.Account.FacebookId {
			selectColumns = append(selectColumns, "facebook_id")
		}
		if relations.Account.IsVerified != nil && *relations.Account.IsVerified {
			selectColumns = append(selectColumns, "is_verified")
		}
		if relations.Account.IsPrivate != nil && *relations.Account.IsPrivate {
			selectColumns = append(selectColumns, "is_private")
		}
		if relations.Account.ProfilePictureUrl != nil && *relations.Account.ProfilePictureUrl {
			selectColumns = append(selectColumns, "profile_picture_url")
		}
		if relations.Account.ExternalUrl != nil && *relations.Account.ExternalUrl {
			selectColumns = append(selectColumns, "external_url")
		}
		if relations.Account.BusinessCategoryName != nil && *relations.Account.BusinessCategoryName {
			selectColumns = append(selectColumns, "business_category_name")
		}
		if relations.Account.CategoryName != nil && *relations.Account.CategoryName {
			selectColumns = append(selectColumns, "category_name")
		}
		if relations.Account.IsBusinessAccount != nil && *relations.Account.IsBusinessAccount {
			selectColumns = append(selectColumns, "is_business_account")
		}
		if relations.Account.IsProfessionalAccount != nil && *relations.Account.IsProfessionalAccount {
			selectColumns = append(selectColumns, "is_professional_account")
		}
		if relations.Account.FollowedByCount != nil && *relations.Account.FollowedByCount {
			selectColumns = append(selectColumns, "followed_by_count")
		}
		if relations.Account.FollowCount != nil && *relations.Account.FollowCount {
			selectColumns = append(selectColumns, "follow_count")
		}
		if relations.Account.MediaCount != nil && *relations.Account.MediaCount {
			selectColumns = append(selectColumns, "media_count")
		}
		if relations.Account.HighlightCount != nil && *relations.Account.HighlightCount {
			selectColumns = append(selectColumns, "highlight_count")
		}
		if relations.Account.HasReels != nil && *relations.Account.HasReels {
			selectColumns = append(selectColumns, "has_reels")
		}
		if relations.Account.ExtractedEmail != nil && *relations.Account.ExtractedEmail {
			selectColumns = append(selectColumns, "extracted_email")
		}
		if relations.Account.HasManagement != nil && *relations.Account.HasManagement {
			selectColumns = append(selectColumns, "has_management")
		}
		if relations.Account.Account != nil && *relations.Account.Account {
			selectColumns = append(selectColumns, "account")
		}
		if relations.Account.CreatedAt != nil && *relations.Account.CreatedAt {
			selectColumns = append(selectColumns, "created_at")
		}
		if relations.Account.UpdatedAt != nil && *relations.Account.UpdatedAt {
			selectColumns = append(selectColumns, "updated_at")
		}
	}
	if relations.ScrapedInstagramAccountChaineds != nil {

		if relations.ScrapedInstagramAccountChaineds.Id != nil && *relations.ScrapedInstagramAccountChaineds.Id {
			selectColumns = append(selectColumns, "id")
		}
		if relations.ScrapedInstagramAccountChaineds.InstagramId != nil && *relations.ScrapedInstagramAccountChaineds.InstagramId {
			selectColumns = append(selectColumns, "instagram_id")
		}
		if relations.ScrapedInstagramAccountChaineds.Username != nil && *relations.ScrapedInstagramAccountChaineds.Username {
			selectColumns = append(selectColumns, "username")
		}
		if relations.ScrapedInstagramAccountChaineds.FullName != nil && *relations.ScrapedInstagramAccountChaineds.FullName {
			selectColumns = append(selectColumns, "full_name")
		}
		if relations.ScrapedInstagramAccountChaineds.Biography != nil && *relations.ScrapedInstagramAccountChaineds.Biography {
			selectColumns = append(selectColumns, "biography")
		}
		if relations.ScrapedInstagramAccountChaineds.FacebookId != nil && *relations.ScrapedInstagramAccountChaineds.FacebookId {
			selectColumns = append(selectColumns, "facebook_id")
		}
		if relations.ScrapedInstagramAccountChaineds.IsVerified != nil && *relations.ScrapedInstagramAccountChaineds.IsVerified {
			selectColumns = append(selectColumns, "is_verified")
		}
		if relations.ScrapedInstagramAccountChaineds.IsPrivate != nil && *relations.ScrapedInstagramAccountChaineds.IsPrivate {
			selectColumns = append(selectColumns, "is_private")
		}
		if relations.ScrapedInstagramAccountChaineds.ProfilePictureUrl != nil && *relations.ScrapedInstagramAccountChaineds.ProfilePictureUrl {
			selectColumns = append(selectColumns, "profile_picture_url")
		}
		if relations.ScrapedInstagramAccountChaineds.ExternalUrl != nil && *relations.ScrapedInstagramAccountChaineds.ExternalUrl {
			selectColumns = append(selectColumns, "external_url")
		}
		if relations.ScrapedInstagramAccountChaineds.BusinessCategoryName != nil && *relations.ScrapedInstagramAccountChaineds.BusinessCategoryName {
			selectColumns = append(selectColumns, "business_category_name")
		}
		if relations.ScrapedInstagramAccountChaineds.CategoryName != nil && *relations.ScrapedInstagramAccountChaineds.CategoryName {
			selectColumns = append(selectColumns, "category_name")
		}
		if relations.ScrapedInstagramAccountChaineds.IsBusinessAccount != nil && *relations.ScrapedInstagramAccountChaineds.IsBusinessAccount {
			selectColumns = append(selectColumns, "is_business_account")
		}
		if relations.ScrapedInstagramAccountChaineds.IsProfessionalAccount != nil && *relations.ScrapedInstagramAccountChaineds.IsProfessionalAccount {
			selectColumns = append(selectColumns, "is_professional_account")
		}
		if relations.ScrapedInstagramAccountChaineds.FollowedByCount != nil && *relations.ScrapedInstagramAccountChaineds.FollowedByCount {
			selectColumns = append(selectColumns, "followed_by_count")
		}
		if relations.ScrapedInstagramAccountChaineds.FollowCount != nil && *relations.ScrapedInstagramAccountChaineds.FollowCount {
			selectColumns = append(selectColumns, "follow_count")
		}
		if relations.ScrapedInstagramAccountChaineds.MediaCount != nil && *relations.ScrapedInstagramAccountChaineds.MediaCount {
			selectColumns = append(selectColumns, "media_count")
		}
		if relations.ScrapedInstagramAccountChaineds.HighlightCount != nil && *relations.ScrapedInstagramAccountChaineds.HighlightCount {
			selectColumns = append(selectColumns, "highlight_count")
		}
		if relations.ScrapedInstagramAccountChaineds.HasReels != nil && *relations.ScrapedInstagramAccountChaineds.HasReels {
			selectColumns = append(selectColumns, "has_reels")
		}
		if relations.ScrapedInstagramAccountChaineds.ExtractedEmail != nil && *relations.ScrapedInstagramAccountChaineds.ExtractedEmail {
			selectColumns = append(selectColumns, "extracted_email")
		}
		if relations.ScrapedInstagramAccountChaineds.HasManagement != nil && *relations.ScrapedInstagramAccountChaineds.HasManagement {
			selectColumns = append(selectColumns, "has_management")
		}
		if relations.ScrapedInstagramAccountChaineds.Account != nil && *relations.ScrapedInstagramAccountChaineds.Account {
			selectColumns = append(selectColumns, "account")
		}
		if relations.ScrapedInstagramAccountChaineds.CreatedAt != nil && *relations.ScrapedInstagramAccountChaineds.CreatedAt {
			selectColumns = append(selectColumns, "created_at")
		}
		if relations.ScrapedInstagramAccountChaineds.UpdatedAt != nil && *relations.ScrapedInstagramAccountChaineds.UpdatedAt {
			selectColumns = append(selectColumns, "updated_at")
		}
	}

	if len(selectColumns) > 0 {
		queryMods = append(queryMods, qm.Select(selectColumns...))
	}

	return queryMods, nil
}

type ScrapedInstagramAccountChainedRelations struct {
	Account                 *SelectScrapedInstagramAccountChainedColumns `boil:"account" json:"account" toml:"account" yaml:"account"`
	ScrapedInstagramAccount *SelectScrapedInstagramAccountChainedColumns `boil:"scrapedInstagramAccount" json:"scrapedInstagramAccount" toml:"scrapedInstagramAccount" yaml:"scrapedInstagramAccount"`
}

func parseScrapedInstagramAccountChainedRelations(relations string) (*ScrapedInstagramAccountChainedRelations, error) {
	var relationsValue ScrapedInstagramAccountChainedRelations
	if err := json.Unmarshal([]byte(relations), &relationsValue); err != nil {
		return nil, err
	}

	return &relationsValue, nil
}

func parseScrapedInstagramAccountChainedRelationsToMods(relations *ScrapedInstagramAccountChainedRelations) ([]qm.QueryMod, error) {
	var queryMods []qm.QueryMod
	var selectColumns []string

	if relations.Account != nil {

		if relations.Account.Id != nil && *relations.Account.Id {
			selectColumns = append(selectColumns, "id")
		}
		if relations.Account.InstagramId != nil && *relations.Account.InstagramId {
			selectColumns = append(selectColumns, "instagram_id")
		}
		if relations.Account.Username != nil && *relations.Account.Username {
			selectColumns = append(selectColumns, "username")
		}
		if relations.Account.FullName != nil && *relations.Account.FullName {
			selectColumns = append(selectColumns, "full_name")
		}
		if relations.Account.ProfilePictureUrl != nil && *relations.Account.ProfilePictureUrl {
			selectColumns = append(selectColumns, "profile_picture_url")
		}
		if relations.Account.ScrapedInstagramAccount != nil && *relations.Account.ScrapedInstagramAccount {
			selectColumns = append(selectColumns, "scraped_instagram_account")
		}
		if relations.Account.Account != nil && *relations.Account.Account {
			selectColumns = append(selectColumns, "account")
		}
		if relations.Account.CreatedAt != nil && *relations.Account.CreatedAt {
			selectColumns = append(selectColumns, "created_at")
		}
		if relations.Account.UpdatedAt != nil && *relations.Account.UpdatedAt {
			selectColumns = append(selectColumns, "updated_at")
		}
	}
	if relations.ScrapedInstagramAccount != nil {

		if relations.ScrapedInstagramAccount.Id != nil && *relations.ScrapedInstagramAccount.Id {
			selectColumns = append(selectColumns, "id")
		}
		if relations.ScrapedInstagramAccount.InstagramId != nil && *relations.ScrapedInstagramAccount.InstagramId {
			selectColumns = append(selectColumns, "instagram_id")
		}
		if relations.ScrapedInstagramAccount.Username != nil && *relations.ScrapedInstagramAccount.Username {
			selectColumns = append(selectColumns, "username")
		}
		if relations.ScrapedInstagramAccount.FullName != nil && *relations.ScrapedInstagramAccount.FullName {
			selectColumns = append(selectColumns, "full_name")
		}
		if relations.ScrapedInstagramAccount.ProfilePictureUrl != nil && *relations.ScrapedInstagramAccount.ProfilePictureUrl {
			selectColumns = append(selectColumns, "profile_picture_url")
		}
		if relations.ScrapedInstagramAccount.ScrapedInstagramAccount != nil && *relations.ScrapedInstagramAccount.ScrapedInstagramAccount {
			selectColumns = append(selectColumns, "scraped_instagram_account")
		}
		if relations.ScrapedInstagramAccount.Account != nil && *relations.ScrapedInstagramAccount.Account {
			selectColumns = append(selectColumns, "account")
		}
		if relations.ScrapedInstagramAccount.CreatedAt != nil && *relations.ScrapedInstagramAccount.CreatedAt {
			selectColumns = append(selectColumns, "created_at")
		}
		if relations.ScrapedInstagramAccount.UpdatedAt != nil && *relations.ScrapedInstagramAccount.UpdatedAt {
			selectColumns = append(selectColumns, "updated_at")
		}
	}

	if len(selectColumns) > 0 {
		queryMods = append(queryMods, qm.Select(selectColumns...))
	}

	return queryMods, nil
}
